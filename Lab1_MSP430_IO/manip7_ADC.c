/*
 * manip7_ADC.c
 *
 *  Created on: 6 oct. 2017
 *      Author: AV
 */

#include <msp430.h>

#define TICK_PER_MS 1000 // tick per ms

#define PWM_MIN_DUTY_MS 0.8f
#define PWM_MAX_DUTY_MS 2.2f
#define PWM_PERIOD_MS 20  // period (ms) of pwm that control the servo.

#define SAMPLE_PERIOD 50 // ms
#define ADC10_RANGE 1024.0f



// ADC10 ISR
#pragma vector=ADC10_VECTOR
__interrupt void ac10_isr(void)
{
	ADC10CTL0 &= ~ADC10IFG;  //clear interrupt request (seems that it is not needed)
	// map result of conversion to the range of the acceptable PWM duties
	unsigned int ADC_RESULT = ADC10MEM;
	float duty_ms = PWM_MIN_DUTY_MS + (ADC_RESULT / ADC10_RANGE) * (PWM_MAX_DUTY_MS - PWM_MIN_DUTY_MS);
	// update TimerA1 CCR1
	TA1CCR1 = (unsigned int)(duty_ms * TICK_PER_MS);
	ADC10CTL0 |= ENC; // enable conversion (if I'm not mistaken ENC is reset after conversion TODO check)
	// TODO reset timer ? wait for right time to change duty ?
	// TODO low power mode etc..
}

void init_GPIO()
{
	// init P1.1 ("output" of potentiometer, input of ADC10)
	P1DIR &= ~BIT1;  // P1.1 as input
	P1SEL |= BIT1;   // P1.1 as peripheral (A1)
	//P1REN |= BIT1;	 // P1.1 resistor enable => for pull down
	//P1OUT &= ~BIT1;	 // P1.1 pulled to GND => no initial floating values

	// init P1.3 (GND of potentiometer)
	P1DIR |= BIT3;	// P1.3 as output
	P1SEL &= ~BIT3;	// P1.3 as I/O
	P1OUT &= ~BIT3; // initially 0 / GND

	// init P2.1 (input of servo, PWM generated by TimerA1 OUT1 (TA1.1))
	P2DIR |= BIT1;	// P2.1 as output
	P2SEL |= BIT1;	// P2.1 as peripheral (TA1.1)

	// init P1.6 to see the sample pwm generated by TimerA0 (visible on out1 (TA0.1))
	P1DIR |= BIT6;  // P1.6 as output
	P1SEL |= BIT6;  // P1.6 as peripheral (TA0.1)
}

void init_CLK()
{
	// setup source of SMCLK
	DCOCTL = CALDCO_1MHZ;  	// setup DCO
	//BCSCTL1 = CALBC1_1MHZ;
}


void init_TimerA0(float periodms)
{
	//Reset timer
	TA0CTL = TACLR;  // reset TAR, divider and count direction

	TA0CCR0 = (unsigned int)(periodms * TICK_PER_MS);
	TA0CCR1 = (unsigned int)(1 * TICK_PER_MS);

	//setup CCR1 : PWM on TA0.1 => visible on P1.2 or P1.6 // Output mode 7 : Reset-Set
	TA0CCTL1 |= OUTMOD_7;

	TA0CTL = TASSEL_2 | MC_1 | ID_0; // SMCLK / Up mode to CCR0 / no divider
}

void init_TimerA1(float periodms, float dutyms)
{

	//Reset timer
	TA1CTL = TACLR;  // reset TAR, divider and count direction

	TA1CCR0 = (unsigned int)(periodms * TICK_PER_MS);
	TA1CCR1 = (unsigned int)(dutyms * TICK_PER_MS);

	//setup CCR1 : PWM on TA1.1 => visible on P2.1 // Output mode 7 : Reset-Set
	TA1CCTL1 |= OUTMOD_7;

	TA1CTL = TASSEL_2 | MC_1 | ID_0; // SMCLK / Up mode to CCR0 / no divider

}

void init_ADC(void)
{
	ADC10CTL0 |= ADC10ON | ADC10IE ;//| ADC10SHT_1 | REFON | REF2_5V;  // "on" (enable ADC core) + enable interupts
	ADC10CTL1 = INCH_1 | SHS_1 | ADC10SSEL_3;// input channel: A1 (P1.1) + sample/hold source: TA0.1 + source clock: SMCLK

	ADC10AE0 |= BIT1; // analog input enabled on A1 (P1.1)
	ADC10CTL0 |= ENC; // enable conversion (CANNOT CONFIGURE WHEN ENC is set...)
}

void run()
{
	init_CLK();
	init_GPIO();
	init_ADC();
	// note: no divider on the clocks and timers => 1000 ticks = 1ms = 1000 clock counts, max count = 65535
	init_TimerA0(SAMPLE_PERIOD);
	init_TimerA1(PWM_PERIOD_MS, PWM_MIN_DUTY_MS);
	while(1);
}
